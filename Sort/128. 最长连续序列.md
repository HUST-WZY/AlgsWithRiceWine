这一题如果用排序来做，思路是很清晰的：相邻的数在排序之后会挨在一起，然后我们遍历数组，看前一个数和后一个数是否相差1，如果是就是连续的，就计数；如果不是了，当前的计数结束，跟答案比较一下，如果大于答案，就更新答案。注意，还有可能是重复的，就是相邻的两个数是一样的，那就跳过这个就好了。

那么时间复杂度就是排序的时间复杂度了：`O(nlogn)`，空间也没有用什么空间，就是`O(1)`。

```java
public int longestConsecutive(int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    
    Arrays.sort(nums);
    
    int maxLen = 1;
    int curLen = 1;
    int pre = nums[0];
    
    for (int i = 1; i < n; ++i) {
        if (nums[i] == pre) {
            continue;
        }
        if (nums[i] == pre + 1) {
            curLen++;
        } else {
            if (curLen > maxLen) {
                maxLen = curLen;
            }
            curLen = 1;
        }
        pre = nums[i];
    }
    
    if (curLen > maxLen) {
        maxLen = curLen;
    }
    
    return maxLen;
    
}
```
