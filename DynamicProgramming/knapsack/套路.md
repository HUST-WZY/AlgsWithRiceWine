## 背包问题 

`01背包`问题的原型：

> 有`n`件物品，它们要装入背包中，所占的容量分别为`w[0]`、`w[1]`、...、`w[n - 1]`；它们所拥有的价值分别为`v[0]`、`v[1]`、...、`v[n - 1]`。
>
> 有一个容量为`C`的背包，如何使包内物品的总价值最大？

该问题的特点是：每个物品仅有一个，也就是仅可以使用一次，可以选择放或者是不放。

```
dp[i][j]: 处理完前i个物品，这前i个物品中，有的可能被放入背包了，有的可能没有被放入，所有被放入背包中的物品所占的总容量为j。在这种情况下，背包内物品的最大价值。

return dp[N][C]
```

```
如果第i个物品没有被放入背包中: dp[i][j] = dp[i - 1][j]
如果第i个物品被放入背包中: 
	这其实要先讨论第i个物品是否能被放入背包内，即背包是否还有足够的容量
	第i个物品，所占的空间为 w[i - 1]，所拥有的价值为 v[i - 1]
	按照我们动态规划数组的定义，放入第i个物品后，包中所有物品的总容量为 j
	那肯定要有：w[i - 1] <= j
	当满足时：
		dp[i][j] = dp[i - 1][j - w[i - 1]] + v[i - 1]
		
那么到底是否放入背包，就要比较放入后的总价值大还不放入的总价值大了：
if (j - wt[i - 1] >= 0):
	dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);
else:
	dp[i][j] = dp[i - 1][j]
```

```
dp[0][i] = 0
dp[i][0] = 0
```

那么基础版的动态规划代码就有了：

```java
public int knapsack(int C, int N, int[] w, int[] v) {
    int[][] dp = new int[N + 1][C + 1];
    
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= C; j++) {
            if (j - w[i - 1] >= 0) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1]);
            }
            else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
        
    return dp[N][C];
}
```

我们可以做一下空间优化。

但是在这里要注意了，对于`j`的遍历，就不能再是升序了。因为要确定当前的`j`，我们需要用到上一行即上一次`i`对应的`j - w[i - 1]`。如果升序，那我们用到的其实是这一行对应的`j - w[i - 1]`，因为升序遍历到`j`时，`j - w[i - 1]`肯定已经遍历过了，已经来到了当前这一行；降序时，遍历到`j`时，`j - w[i - 1]`在本次是没有被遍历过的，所以还是上一行的。

```java
public int knapsack(int C, int N, int[] w, int[] v) {
    int[] dp = new int[C + 1];
    
    for (int i = 1; i <= N; i++) {
        for (int j = C; j >= 0; j--) {
            if (j - w[i - 1] >= 0) {
                dp[j] = Math.max(dp[j], dp[j - w[i - 1]] + v[i - 1]);
            } else {
                dp[j] = dp[j];
            }
        }
    }
                
    return dp[C];
}
```

那我们看到对于`j`，其实只有在`j >= w[i - 1]`时才是有效的，所以不妨令`j`遍历的终点就是`w[i - 1]`吧。

```java
public int knapsack(int C, int N, int[] w, int[] v) {
    int[] dp = new int[C + 1];
    
    for (int i = 1; i <= N; i++) {
        for (int j = C; j >= w[i - 1]; j--) {
            dp[j] = Math.max(dp[j], dp[j - w[i - 1]] + v[i - 1]);
        }
    }
                
    return dp[C];
}
```

在实际的问题中，很多情况下，`w`和`v`可能只有一个，很可能是只有`w`。

## 套路总结

对于上述讨论，我们认为，背包问题的目标，就是要达到某个`target`，对于上面的问题，就是装满背包，所以`target = C`。而用谁来达到`target`呢？会用`nums[]`中的数。

上面的说话还是比较抽象，我们先把套路写出来

1. 如果`nums[]`中的数，需要`按顺序`被拿出来去完成`target`

   ```java
   for (int i = 1; i <= target; ++i) {
       for (int num : nums) {
           dp...
       }
   }
   ```

2. 不需要按顺序

   1. `nums[]`中的数只能使用一次，这就类似上面`01背包`的情况了

      ```java
      for (int num : nums) {
          for (int i = target; i >= num; --i) {
              dp...
          }
      }
      ```

   2. `nums[]`中的数能使用多次

      ```java
      for (int num : nums) {
          for (int i = num; i <= target; ++i) {
              dp...
          }
      }
      ```

## 套路演练

上面的套路确实过于抽象，而且好像跟`01背包问题`也没有联系上。接下来我们实际演练一下，可能就会看得更清楚一点啦。
