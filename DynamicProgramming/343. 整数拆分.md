把一个整数拆分成若干份，它们的和为原整数，然后要使它们的积最大。

根据我们对数学的直觉，如果拆成两份，那这两份要尽可能相等，积才会最大：

* 偶数：对半拆分

* 奇数：正中间的和它靠前一位的

那如果是拆成3份或者更多呢？我们会考虑这样的积会不会比拆成两份要大，事实可能就是会大的。但是就没法想了，就动态规划了。

* 矩阵元素定义：

`dp[i]`:将`i`拆成三份或更多，得到的积的最大值

* 初始条件：

`dp[1] = 1`

* 递推公式

我们先假设一个数，比如`i=100`，那它肯定满足：

    dp[100] = max(dp[100 - i] * i), i = 1,2,3,...,99
    
这其中，`dp[100 - 1] * 1`、`dp[100 - 2] * 2`、`dp[100 - 3] * 3`、`dp[100 - 4] * 4` 都没有问题，但是我们看`dp[100 - 5] * 5`，5是可以再拆成`2 + 3`的，那么显然 `dp[100 - 5] * 5 < dp[100 - 5] * 2 * 3`，而 乘2乘3 的在前面都有体现了，所以，5就没有必要要了。那么5往后，都是同样的问题了。所以，我们的递推公式就可以写成：

    dp[i] = max(dp[i - j] * j), j = 1,2,3,4, i - j >= 1

时间复杂度为`O(n)`，空间复杂度为`O(n)`。

```java
public int integerBreak(int n) {

    int[] dp = new int[n + 1];

    dp[1] = 1;

    for (int i = 2; i <= n; ++i) {
        int max = twoBreak(i);
        for (int j = 1; j <= 4 && i - j >= 1; ++j) {
            max = Math.max(max, dp[i - j] * j);
        }
        dp[i] = max;
    }

    return dp[n];

}

public int twoBreak(int n) {
    if (n % 2 == 0) {
        return (n / 2) * (n / 2);
    }
    return (n / 2) * (n / 2 + 1);
}
```
