首先我们读懂题目的意思：

    用 s 去匹配 p，如果 p 中有 . ，那在那个位置上就能跟 s 中任意单个字符匹配；
    
    如果 p 中有 * ，那么 p 中 * 前面的字符，在 s 中对应位置可以有连续的 0 个或多个。
    
我们首先定义个方法，比较`s`的第`i`个和`p`的第`j`个吧。注意，第几个，那这个几就要从1开始；然后如果`p`中为`.`，那就都能匹配。

```java
public boolean isMatchOne(char[] s, char[] p, int i, int j) {
    if (i <= 0 || j <= 0) {
        return false;
    }
    if (p[j - 1] == '.') {
        return true;
    }
    return s[i - 1] == p[j - 1];
}
```

然后，动态规划。

`dp[i][j]`表示`s`的前`i`个与`p`的前`j`个是否匹配。

递推，先考虑两种情况：

* `s`的第`i`个与`p`的第`j`个都不为`*`

那就只要看下我们定义的方法，如果是`true`，就去看`dp[i-1][j-1]`就好啦；否则就是`false`。

* `p`的第`j`个为`*`

首先此时，`p`的后两个是一个字符和`*`，这两个其实是
