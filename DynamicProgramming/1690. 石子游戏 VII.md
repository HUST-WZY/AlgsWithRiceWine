首先，我们知道：先手肯定赢，那么现在只是赢多赢少的问题；然后，我们定义：`dp[i][j]` 表示对于从索引`i`到索引`j`的石子，先手赢的最大分差；那么我们就可以考虑几种情况了：

* 只有一颗石子

  先手拿，拿完剩下的是 0；那后手也是 0；都是 0，分差也是 0。所以`dp[i][i] = 0`。

* 只有两颗石子

  先手拿，拿完剩一个，是先手的得分；后手拿那剩的一个，拿完是 0。所以剩的那一个，就是分差。为了让分差大，先手肯定会让更大的那个剩下，所以`dp[i][i + 1] = max(piles[i], piles[i + 1])`

* 只有三颗石子

  先手拿，拿完剩两个，这两个是先手的得分；后手从剩的两个中拿一个，剩下一个是后手的得分；然后再拿就是剩下 0 了。所以，后手拿的那个，就是分差；后手想让分差减小，所以它会拿小的。那为了让分差最大，就分类讨论下先手拿哪一个：`dp[i][i + 2] = max(min(dp[i], dp[i + 1]), min(dp[i + 1], dp[i + 2]))`。

* 有三颗以上的石子

  从一种情况我们发现：分差的大小取决于后手的选择，而后手是要选小的；当然也取决于先手的，先手可能要大的。我们可以讨论一下先手的选择，再讨论后手的选择：

  * 先手选左边的，留给后手的是从`i + 1`到`j`，得分是从`i + 1`到`j`

    * 后手选左边的，留给先手的是从`i + 2`到`j`，得分是从`i + 2`到`j`

      * 所以这一把的分差是 `piles[i + 1]`，之后把的分差就是`dp[i + 2][j]`
      * 总分差`piles[i + 1] + dp[i + 2][j]`

    * 后手选右边的，留给显瘦的是从`i + 1` 到 `j - 1`，得分是从`i + 1` 到 `j - 1`

      * 所以这一把的分差是 `piles[j]`，之后把的分差就是`dp[i + 1][j - 1]`
      * 总分差`piles[j] + dp[i + 1][j - 1]`

    * 后手要分差小，所以后手最终会选择：

      `left = min(piles[i + 1] + dp[i + 2][j], piles[j] + dp[i + 1][j - 1])`

  * 先手选右边的，留给后手的是从`i`到`j - 1`，得分是从`i`到`j - 1`

    * 后手选左边的，留给先手的是从`i + 1` 到 `j - 1`，得分是从`i + 1` 到 `j - 1`

      * 所以这一把的分差是 `piles[i]`，之后把的分差就是`dp[i + 1][j - 1]`
      * 总分差`piles[i] + dp[i + 1][j - 1]`

    * 后手选右边的，留给先手的是从`i ` 到 `j - 2`，得分是从`i ` 到 `j - 2`

      * 所以这一把的分差是 `piles[j - 1]`，之后把的分差就是`dp[i][j - 2]`
      * 总分差`piles[j - 1] + dp[i][j - 2]`

    * 后手要分差小，所以后手最终会选择：

      `right = min(piles[i] + dp[i + 1][j - 1], piles[j - 1] + dp[i][j - 2])`

  * 先手要分差大，所以先手会选择：

    `dp[i][j] = max(left, right)`

  然后仔细想想，三颗石子 的情况是可以合到这种里面的。

之后就是代码，通过递推可以看到，想要知道当前的`dp`值，必须知道它左边和下边的值，而且初始条件又是斜着的，所以要斜着遍历数组。下面是斜着遍历二维数组的代码，如果是从主对角线开始遍历，`m`就从0开始，对角线上移一位`m`的初始值就加一。

```java
for (int m = 0; m < n; m++) 
	for (int i = 0; i < n - m; i++) {
    	int j = i + m;
        nums[i][j]...
    }
}
```

本题，前两种情况做了数组的初始化，所以我们从第三条对角线开始遍历，`m`的初始值为2。

时间复杂度为`O(n^2)`，空间复杂度为`O(n^2)`。

```java
public static int stoneGameVII(int[] piles) {

    int n = piles.length;
    int[][] dp = new int[n][n];

    for (int i = 0; i < n - 1; ++i) {
        dp[i][i + 1] = Math.max(piles[i], piles[i + 1]);
    }

    for (int m = 2; m < n; m++) {
        for (int i = 0; i < n - m; i++) {
            int j = i + m;
            int left = Math.min(piles[i + 1] + dp[i + 2][j], piles[j] + dp[i + 1][j - 1]);
            int right = Math.min(piles[i] + dp[i + 1][j - 1], piles[j - 1] + dp[i][j - 2]);
            dp[i][j] = Math.max(left, right);
        }
    }

    return dp[0][n - 1];

}
```
