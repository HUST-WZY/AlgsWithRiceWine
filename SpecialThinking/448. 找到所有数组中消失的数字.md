当题目中有数组，并且说了数组的值的范围`0 <= nums[i] <= n - 1`，或者是`1 <= nums[i] <= n`，那些显然值的范围跟索引的范围有一定了关系了，可以考虑在遍历数组时，把当前遍历到的元素的值，作为索引，进行一定的处理。

对于这一题，我们先遍历一遍数组，对于遍历到的每个元素，找值对应的索引处的元素，并将找到的值加上`n`。这样做的效果是，原本值域为`1 <= nums[i] <= n`，减一，完全映射到索引`index`：`0 <= nums[i] - 1 <= n - 1`；索引处元素的值域为`1 <= nums[index] <= n`，将它加上`n`，值域为`1 + n <= nums[index] <= 2 * n`；这样凡是被值索引过的元素，跟没有给值索引过的元素就区分开来了。

但是有可能某个元素，被值索引多次。那第一次被索引后值域大于`n`了，之后再减一，就不是索引了。由于我们加上的是`n`，所以很常规的技巧，值减一后再对`n`取余，那不管加了多少次`n`，取余后，得到的值域都是`0 <= nums[i] <= n - 1`了。

最后我们再遍历一遍`nums`，那么凡是小于等于`n`的，都是没有被值索引过的元素，也就是说它们的索引对应的值没有出现在数组中。注意首先是索引，其实是对应，在本题中，索引加一才是对应的值。

时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```java
public List<Integer> findDisappearedNumbers(int[] nums) {
  List<Integer> ans = new ArrayList<>();
    int n = nums.length;
    for (int num : nums) {
        int index = (num - 1) % n;
        nums[index] += n;
    }
    for (int i = 0; i < n; i++) {
        if (nums[i] <= n) {
            ans.add(i + 1);
        }
    }
    return ans;
}
```

