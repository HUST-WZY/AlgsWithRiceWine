`dfs`的解法跟[bfs](https://github.com/HUST-WZY/AlgsWithRiceWine/blob/main/Backtrack/BFS/765.%20%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B.md)思路一样。

只是注意，由于`dfs`方法要进行递归，所以把计数变量做成全局变量吧。

时间复杂度为`O(n)`，除了建图循环的`n`，在`dfs`中，`n`个点每个点都会被访问一次的，所以总的是`O(n)`。空间复杂度为`O(n)`。

```java
boolean[] visited;
int ans = 0;

public int minSwapsCouples(int[] row) {
    int n = row.length;
    int tot = n / 2;
    
    List<Integer>[] graph = buildGraph(n, row);
    
    visited = new boolean[tot];

    for (int i = 0; i < tot; i++) {
        visited[i] = true;
        dfs(graph, i);
    }
    return ans;
}

private void dfs(List<Integer>[] graph, int x) {
    for (int y : graph[x]) {
        
        if (visited[y]) {
            continue;
        }
        
        visited[y] = true;
        ans++;
        dfs(graph, y);
    }
}

private List<Integer>[] buildGraph(int n, int[] row) {
    List<Integer>[] graph = new List[n / 2];
    
    for (int i = 0; i < n / 2; i++) {
        graph[i] = new ArrayList<Integer>();
    }
    
    for (int i = 0; i < n; i += 2) {
        int l = row[i] / 2;
        int r = row[i + 1] / 2;
        if (l != r) {
            graph[l].add(r);
            graph[r].add(l);
        }
    }
    
    return graph;
}
```
