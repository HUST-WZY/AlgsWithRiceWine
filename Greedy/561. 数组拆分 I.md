我们首先应该把题意读明白。

一共有`2 * n`个数，那就组成了`n`对数；它们怎么组成`n`对数，就有很多种方法了。那么这`n`对数，每对都会有个最小值，`n`个最小值相加，得到`最小值的和`。用不同的方式得到`n`对数，那就会得到不同的`最小值的和`。这些不同的`最小值的和`中，有个最大的，题目就是让求这个最大的。

那我们就考虑，最终是要求最大的和的，首先我们考虑`2 * n`个数中最大的数`max`，最终，我们是不可能把`max`加入到`最小值的和`中的，因为`nums`中没有数比`max`小了。但是可以用`2 * n`个数中次大的数`max2 `，它是剩下的可能加入`最小值的和`中的最大的数了，贪心的思想，我们一定要用它；但是如果要用它，必须把它和最大的数配对，即`[max, max2]`。至此，这两个数配对了，我们就把它们从`nums`中剔除吧。

那么`nums`中剩下的数，又有最大的数`max`和次大的数`max2`，还是像上面那样去考虑。直到考虑到`nums`中最小的两个数。

所以最终，我们只要把`nums`中的数排序，然后把偶数位数都加起来就好。

时间复杂度为`O(n * log(n))`，空间复杂度为`O(log(n))`。都是快排的时间复杂度和递归的栈空间。

```java
public int arrayPairSum(int[] nums) {
    Arrays.sort(nums);
    
    int ans = 0;
    for (int i = 0; i < nums.length; i += 2) {
        ans += nums[i];
    }
    return ans;
}
```
