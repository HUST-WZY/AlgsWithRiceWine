`people`数组中，第一个维度为身高，第二个维度代表在它之前比第一维的身高高或相等的人的个数。我们可以把第二个维度视为从0开始的索引：假设说所有人的身高都相同，那第二个维度就是索引。那么先看最高的一帮人，他们可以按照索引先排个序；第二高的一帮人，就按照它们的索引往最高的排好序的队列里插：这个操作不会改变最高的人的相对顺序，即最高的人的第二个维度还是维护着的；同时第二高的人也是根据第二维度的索引插入的，也会维护。那么接下来就类推了/

为了完成上述过程，我们先将`people`数组按照第一维度降序排列（即把最高的放前面，后面遍历时先排最高的），当第一维度相同时，按照第二维度升序排列（把它视为索引，当然就升序了）。然后就遍历`people`，每次都把遍历到的`1*2`的数字对，插入到第二个维度即索引的位置即可。

时间复杂度为`O(nlogn)`，空间复杂度为`O(n)`，其中n为人数。

```java
public int[][] reconstructQueue(int[][] people) {
	Arrays.sort(people, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));
    List<int[]> ans = new LinkedList<>();
    for (int[] ple : people) {
        int insertIndex = ple[1];
        ans.add(insertIndex, ple);
    }
    return ans.toArray(new int[people.length][2]);
}
```
