这一题，用暴力方法做的话很简单，但是简洁的方法会发现技巧满满。

首先，题目的意思是两个数字可以反转，而且数字的大小是`0-9`。那么，不管怎么反转，不管遇到哪个数字，我都让大的在前面，小的在后面，这不就行了。进一步，数字的范围固定了，那用我们的惯用方法，大的数字乘`10`再加上小的，就唯一表示一个二元组了。

到这里，再结合`map`，其实已经可以做了。但这道题更巧妙的是，由于数字范围固定了，所以我们可以确定，相乘再相加后的数字最大是`99`，最小是`0`。那么我们就可以用数组`nums`了，`值变索引`的思想。这样，我们就能知道，二元组的值为`val`的个数为`nums[val]`。

那知道以后呢？题目求的是组合的个数。我们大可以用`排列组合`的方法来做，但是还有更巧的方法：当我们找到一个二元组的值为`val`以后，它会跟之前我们找到的值为`val`的二元组组合吧，也就是说它就让答案`+ nums[val]`，此时的`nums[val]`，如果前面没有出现过值为`val`的二元组，它就是`0`；如果出现过，它就不为`0`；总之，在更新它之前，用它去更新答案，然后再更新它，就是现在找到了一个值为`val`的二元组，让`nums[val]`加一。

时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```java
public int numEquivDominoPairs(int[][] dominoes) {
    int ans = 0;
    int[] nums = new int[100];
    for (int[] domino : dominoes) {
        int val = domino[0] > domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];
        ans += nums[val];
        nums[val]++;
    }
    return ans;
}
```
