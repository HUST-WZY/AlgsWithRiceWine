这一题的思路其实也就那样，思路好想，但是编码实现起来，细节比较麻烦，所以我们记录一下。

先说思路吧，其实就是双指针。前指针往前走，只要`lo`到`hi`之间的元素符合`湍流数组`的定义，就一直往前走。当不符合定义时，此时`lo`不能只是往前移动一步了，而是要直接跳到`hi`那里，然后`hi`再往前走一步，接着遍历。再这个过程中，维护双指针之间的最大宽度。

那么这里面，就有细节：

* 在`hi`处判断是否符合`湍流数组`的定义，其实就是要判断，`hi`跟它前面和后面的元素的大小关系，符号相反就好。那么就要保证，`hi`前后都是有元素的，即索引不能越界。那我们就让`hi`从`1`开始，到`n - 2`结束，这就保证了前后都有元素。

* 到`n - 2`结束好说，在循环条件处设置`while (hi < n - 1)`就好了。从`1`开始，这个我们需要讨论一下。在两种情况下，`lo`和`hi`会是相等的：

  * 刚开始进入循环时，二者都初始化为`0`；
  * `hi`处不符合`湍流数组`定义时，`lo`会前移，让二者相等。

  相等时，包括了初始的情况，此时我们就让`hi`加一，既在初始时让`hi`从`1`开始了，又能让`lo`往前跳之后，遍历能够继续。

* 数组中，存在相邻的元素相同的情况。此时其实就是不符合`湍流数组`的情况，那`lo`是会往前跳的，这种情况我们在之前已经处理过了；还会有一种情况，就是当`lo == hi`时，我们让`hi`前移了一位，这时如果出现了二者相等，注意是相邻的元素相等，即`arr[lo] == arr[lo + 1]`，我们就让`lo`也前移：移动的结果是`lo`和`hi`又相等了，那就进入下一轮的循环，再去处理`lo == hi`的情况了。

* 最大长度的初值选取，选为`1`。

* 在哪里更新最大长度呢？我们就考虑，之前讨论的不管是哪种情况，都是维护了`lo`和`hi`之间的数组元素满足了`湍流数组`，那我们就都看看当前的指针宽度是否最大。

所以，在每次进入循环时，我们先判断`lo`和`hi`是否相等，不相等的话，再去处理是否是`湍流数组`的情况。

时间复杂度为`O(n)`，空间复杂度为`O(1)`。

```java
public int maxTurbulenceSize(int[] arr) {

    int n = arr.length;
    int ans = 1;
    int lo = 0, hi = 0;

    while (hi < n - 1) {

        if (lo == hi) {

            if (arr[lo] == arr[lo + 1]) {
                lo++;
            }

            hi++;
        } else {

            if (arr[hi] > arr[hi + 1] && arr[hi - 1] < arr[hi]) {
                hi++;
            } else if (arr[hi] < arr[hi + 1] && arr[hi - 1] > arr[hi]) {
                hi++;
            } else {
                lo = hi;
            }

        }

        ans = Math.max(ans, hi - lo + 1);
    }
    return ans;
}
```
