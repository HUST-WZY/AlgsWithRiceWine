首先，情侣们或者每个人的编号，是从`0`到`N - 1`，这里的`N`一定是偶数了。而且，第一对情侣是`0`和`1`，第二对情侣是`2`和`3`，...，最后一对情侣是`N - 2`和`N - 1`。那么我们不妨认为，对于某个人`i`，它应该坐在标号为`i / 2`的位置，这样每对情侣都是坐在同一个位置，都是可以牵手的了。

那么我们这样想：从第一个人`0`开始，他发现他的旁边不是他的情侣`1`，而是另外的一个人`2`；那`0`就要去找，去哪找呢？假设只有两对情侣，那排列方式肯定是`02、13`了，所以`0`要去`2`应该去的地方找，即`2`的情侣所在的地方找；那如果不止两对情侣，`0`先去`2`的情侣所在的地方，到了以后发现那里还不是`1`，再去下一个指向的地方，总会找到的。注意在这个过程中，每找一次，比如`0`找到了`2`要去的地方，就先把`2`换过去：如果只有两对情侣，那换这一次就够了；多于两对，就多换几次，最终肯定会把`1`换回来的。这样走一圈，如果一共有`k`个节点，那其实交换了`k - 1`次。

如果有一对情侣，它们本来就是做好了的，那就会是：不会从别的地方换到它们那里，它们也不会被换去别的地方。

这样，对于可以转一圈换好的那些人，假设一共围成了`k`个圈，每个圈中的有`N1、N2、...、Nk`对人，那交换的次数为`N1 - 1 + N2 - 1 +...+ Nk - 1 = N1 + N2 + ... + Nk - k `；对于已经坐好了的人，假设一共`p`对，那其实也认为是`p`个圈，交换的次数为`0`，认为是`Nk+1 - 1 + Nk+2 - 1 + ... + Nk+p - 1 `，这里的`Ni`都是`1`，加起来还是`0`。但是在计算总的交换次数时，所有的`Ni`加起来就是情侣的总对数，后面所有的`1`加起来，就是围成的总的圈数。

那我们怎么围成圈呢？这不就有点连通性的感觉了，那不就得用并查集了？将一个圈作为并查集中的一个连通分量，那圈数不就是并查集中连通分量的个数？剩下的问题就是如何维护连通性了。

我们令初始时坐在一起的情侣，不管他们实际是不是情侣，都让连通在一起。他们在并查集中的表示，就是他们实际应该坐的位置。我们只遍历偶数位置的人，然后将他与后面位置的人连起来，就好了。这样通过一个个把该连在一起的连起来，再借助并查集的特性，该在一个圈里的人就会自动在同一个连通分量中了。

时间复杂度为`O(n * log(n))`，空间复杂度为`O(n)`。

```java
public int minSwapsCouples(int[] row) {
    int n = row.length;
    UF uf = new UF(n / 2);
    
    for (int i = 0; i < n; i += 2) {
        uf.union(row[i] / 2, row[i + 1] / 2);
    }
    
    return n / 2 - uf.count();
}
```
