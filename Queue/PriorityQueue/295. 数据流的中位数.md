这一题的解法还是很巧妙的。

我们要找中位数嘛，在一列数中找中位数，首先就是要给这一列数排序，然后找中间的数。但是现在的数据是以**流**的形式过来的，也就是说我们事先是不知道要排列的数的所有的。那对这种情况，我们一般是会条件反射地想到`堆`或者`PriorityQueue`。

那么最原始的想法：维护一个堆，有新的数字过来，就加入堆中；当需要得到中位数时，就把堆中的数字拿出来一半，先找个什么数据结构暂时存一下，然后得到中位数。但是这样，得到中位数的操作就会很复杂，时间复杂度会与当前堆中数字的个数成正比。

我们希望降低得到中位数的时间复杂度。方法是，我们要找一列有序数字的中位数嘛，那这个中位数在中间，它前面是一列有序数字，后面是一列有序数字，那我们可以用两个堆来分别存这两列数字嘛。假设一列数是升序排列的，那么大根堆`lo`存靠前的半列数，小根堆`hi`存靠后的半列数，当需要中位数时，拿出两个堆的堆顶元素就可以判断了。而且注意，两个堆的堆顶元素是有大小关系的：`lo.peek() < hi.peek()`。

那么现在的问题就是，如果维护两个只装了半列数字的堆。刚开始，两个堆都是空的，那来了一个数，随便放哪个堆里都行，我们就放`lo`里了；再来一个数，此时`hi`是空的，不能贸然把新的数放入`hi`中，因为要维护两个堆顶的大小关系。当两个堆中都有至少一个元素了，我们之后首先要保证堆的大小之差不超过`1`；来了一个新的数字，我们把它跟两个堆顶元素进行比较：如果新的数字在堆顶元素之间，就挑较小的堆加入就好了，堆一样大就随便都行；如果新的数字比`lo`的堆顶小，就要加入`lo`中，那同时要出堆入堆维护堆的大小之差不超过`1`；如果新的数字比`hi`的堆顶大，同理。

在拿出中位数时，要讨论此时数列的长度是奇数还是偶数。如果是奇数，就是两个堆的大小差一，就把较大的堆的堆顶返回；如果是偶数，就是两个堆的大小相等，就返回两个堆的堆顶元素的平均值。

时间复杂度为`O(log(n))`，其中`n`为当前数据结构中数字的个数，并且这只是`addNum()`方法的，`findMedian()`方法的是`O(1)`。空间复杂度为`O(n)`。

```java
class MedianFinder {

    PriorityQueue<Integer> lo;
    PriorityQueue<Integer> hi;

    /** initialize your data structure here. */
    public MedianFinder() {
        lo = new PriorityQueue<>((a, b) -> (b - a));
        hi = new PriorityQueue<>((a, b) -> (a - b));
    }
    
    public void addNum(int num) {
        if (lo.isEmpty() && hi.isEmpty()) {
            lo.offer(num);
            return;
        }
        
        if (hi.isEmpty()) {
            if (num >= lo.peek()) {
                hi.offer(num);
            } else {
                hi.offer(lo.poll());
                lo.offer(num);
            }
            return;
        }

        int small = lo.peek();
        int large = hi.peek();

        if (num > small && num < large) {
            if (lo.size() <= hi.size()) {
                lo.offer(num);
            } else {
                hi.offer(num);
            }
        } else if (num <= small) {
            lo.offer(num);
            while (Math.abs(lo.size() - hi.size()) > 1) {
                hi.offer(lo.poll());
            }
        } else {
            hi.offer(num);
            while (Math.abs(lo.size() - hi.size()) > 1) {
                lo.offer(hi.poll());
            }
        }
    }
    
    public double findMedian() {
        if (lo.size() > hi.size()) {
            return (double) lo.peek();
        }
        
        if (hi.size() > lo.size()) {
            return (double) hi.peek();
        }
        
        return ((double) hi.peek() + lo.peek()) / 2;
    }
}
```
